(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{433:function(e,t,r){"use strict";r.r(t);var a=r(33),l=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("Java集合概述\n")]),e._v(" "),r("h2",{attrs:{id:"概括"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概括"}},[e._v("#")]),e._v(" 概括")]),e._v(" "),r("h2",{attrs:{id:"_1-关系"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-关系"}},[e._v("#")]),e._v(" 1. 关系")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://gallery.sleepyocean.cn/resource/img/b7dddd521f3d181e98bc8bfb6ff9c2e2",alt:"Java集合-2"}})]),e._v(" "),r("h2",{attrs:{id:"_2-要点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-要点"}},[e._v("#")]),e._v(" 2. 要点")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("Collection")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("List")]),e._v(" "),r("ul",[r("li",[e._v("ArrayList： 底层数据结构是数组，查询快，增删慢；线程不安全，效率高；")]),e._v(" "),r("li",[e._v("Vector： 底层数据结构是数组，查询快，增删慢；线程安全，效率低（几乎不会使用）；")]),e._v(" "),r("li",[e._v("LinkedList： 底层数据结构是链表，查询慢，增删快；线程不安全，效率高；")])])]),e._v(" "),r("li",[r("p",[e._v("Set")]),e._v(" "),r("ul",[r("li",[e._v("HashSet：\n"),r("ol",[r("li",[e._v("不能保证元素顺序，不可重复，不是线程安全，元素可以为null；")]),e._v(" "),r("li",[e._v("底层其实是一个数组，为了加快查询速度。索引就是通过hash值转换，即index=hash(hashCode)；")])])]),e._v(" "),r("li",[e._v("LinkedHashSet：不可重复，有序；")]),e._v(" "),r("li",[e._v("TreeSet： 有序，不可重复，底层使用红黑树算法，擅长范围查询；")])]),e._v(" "),r("p",[r("font",{attrs:{color:"red"}},[e._v("注：实现线程安全的方法： "),r("code",[e._v("Set set = Collections.synchronizedSet(setObj);")])])],1)])])])]),e._v(" "),r("h1",{attrs:{id:"分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[e._v("#")]),e._v(" 分类")]),e._v(" "),r("h2",{attrs:{id:"队列-queue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#队列-queue"}},[e._v("#")]),e._v(" 队列（Queue）")]),e._v(" "),r("p",[e._v("LinkedBlockingQueue的容量是没有上限的（说的不准确，在不指定时容量为Integer.MAX_VALUE，不然的话在put时怎么会受阻呢），但是也可以选择指定其最大容量，它是基于链表的队列，此队列按 FIFO（先进先出）排序元素。")]),e._v(" "),r("p",[e._v("ArrayBlockingQueue在构造时需要指定容量， 并可以选择是否需要公平性，如果公平参数被设置true，等待时间最长的线程会优先得到处理（其实就是通过将ReentrantLock设置为true来达到这种公平性的：即等待时间最长的线程会先操作）。通常，公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队列，此队列按 FIFO（先进先出）原则对元素进行排序。")]),e._v(" "),r("p",[e._v("PriorityBlockingQueue是一个带优先级的 队列，而不是先进先出队列。元素按优先级顺序被移除，该队列也没有上限（看了一下源码，PriorityBlockingQueue是对 PriorityQueue的再次包装，是基于堆数据结构的，而PriorityQueue是没有容量限制的，与ArrayList一样，所以在优先阻塞队列上put时是不会受阻的。虽然此队列逻辑上是无界的，但是由于资源被耗尽，所以试图执行添加操作可能会导致 OutOfMemoryError），但是如果队列为空，那么取元素的操作take就会阻塞，所以它的检索操作take是受阻的。另外，进入该队列中的元素要具有比较能力。")]),e._v(" "),r("p",[e._v("DelayQueue（基于PriorityQueue来实现的）是一个存放Delayed 元素的无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且poll将返回null。当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于或等于零的值时，则出现期满，poll就以移除这个元素了。此队列不允许使用 null 元素。")])])}),[],!1,null,null,null);t.default=l.exports}}]);